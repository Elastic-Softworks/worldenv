/*
 * SPDX-License-Identifier: ACSL-1.4 OR FAFOL-0.1 OR Hippocratic-3.0
 * Multi-licensed under ACSL-1.4, FAFOL-0.1, and Hippocratic-3.0
 * See LICENSE.txt for full license texts
 */

/**
 * WORLDSRC Semantic Analyzer
 *
 * Comprehensive semantic analysis engine that walks the AST to perform
 * type checking, symbol resolution, and semantic validation for the
 * C/C++/TypeScript hybrid language.
 */

import {
  ASTNode,
  Program,
  Declaration,
  Statement,
  Expression,
  FunctionDeclaration,
  ClassDeclaration,
  InterfaceDeclaration,
  StructDeclaration,
  VariableDeclaration,
  TypeAliasDeclaration,
  NamespaceDeclaration,
  BlockStatement,
  ExpressionStatement,
  IfStatement,
  WhileStatement,
  ForStatement,
  ReturnStatement,
  BinaryExpression,
  UnaryExpression,
  CallExpression,
  MemberExpression,
  AssignmentExpression,
  Identifier,
  Literal
} from '../parser/ast';

import {
  Symbol,
  SymbolKind,
  SymbolVisibility,
  SymbolTable,
  Scope,
  ScopeType,
  FunctionSignature,
  TypeInfo,
  TemplateParameter,
  globalSymbolTable
} from './symbol-table';

import {
  TypeDescriptor,
  TypeKind,
  TypeRegistry,
  TypeChecker,
  globalTypeRegistry,
  globalTypeChecker
} from './type-system';

import {
  SourceLocation,
  globalErrorHandler,
  ErrorType
} from '../error/error-handler';

export interface AnalysisContext {
  currentFunction?: Symbol;
  currentClass?: Symbol;
  currentNamespace?: Symbol;
  returnType?: TypeDescriptor;
  isInLoop: boolean;
  isInSwitch: boolean;
  templateParameters?: TemplateParameter[];
}

export interface AnalysisResult {
  success: boolean;
  errors: number;
  warnings: number;
  symbolTable: SymbolTable;
  typeRegistry: TypeRegistry;
}

export class SemanticAnalyzer {
  private symbolTable: SymbolTable;
  private typeRegistry: TypeRegistry;
  private typeChecker: TypeChecker;
  private context: AnalysisContext;
  private currentNode?: ASTNode;

  constructor(
    symbolTable = globalSymbolTable,
    typeRegistry = globalTypeRegistry,
    typeChecker = globalTypeChecker
  ) {
    this.symbolTable = symbolTable;
    this.typeRegistry = typeRegistry;
    this.typeChecker = typeChecker;
    this.context = {
      isInLoop: false,
      isInSwitch: false
    };
  }

  /**
   * Analyze complete program
   */
  public analyze(program: Program): AnalysisResult {
    const startErrors = globalErrorHandler.getErrorCount();
    const startWarnings = globalErrorHandler.getWarningCount();

    try {
      this.visitProgram(program);
    } catch (error) {
      globalErrorHandler.reportInternalError(
        `Semantic analysis failed: ${(error as Error).message}`,
        error as Error,
        this.getNodeLocation(this.currentNode)
      );
    }

    const errors = globalErrorHandler.getErrorCount() - startErrors;
    const warnings = globalErrorHandler.getWarningCount() - startWarnings;

    return {
      success: errors === 0,
      errors,
      warnings,
      symbolTable: this.symbolTable,
      typeRegistry: this.typeRegistry
    };
  }

  /**
   * Visit program node
   */
  private visitProgram(program: Program): void {
    this.currentNode = program;

    /* First pass: Collect all declarations for forward references */
    for (const declaration of program.declarations) {
      this.collectDeclaration(declaration);
    }

    /* Second pass: Analyze all declarations */
    for (const declaration of program.declarations) {
      this.visitDeclaration(declaration);
    }

    /* Third pass: Validate forward declarations */
    this.validateForwardDeclarations();
  }

  /**
   * Collect declarations for forward reference resolution
   */
  private collectDeclaration(declaration: Declaration): void {
    this.currentNode = declaration;

    switch (declaration.constructor.name) {
      case 'FunctionDeclaration':
        this.collectFunctionDeclaration(declaration as FunctionDeclaration);
        break;
      case 'ClassDeclaration':
        this.collectClassDeclaration(declaration as ClassDeclaration);
        break;
      case 'InterfaceDeclaration':
        this.collectInterfaceDeclaration(declaration as InterfaceDeclaration);
        break;
      case 'StructDeclaration':
        this.collectStructDeclaration(declaration as StructDeclaration);
        break;
      case 'NamespaceDeclaration':
        this.collectNamespaceDeclaration(declaration as NamespaceDeclaration);
        break;
    }
  }

  /**
   * Collect function declaration
   */
  private collectFunctionDeclaration(funcDecl: FunctionDeclaration): void {
    const returnType = this.convertTypeNode(funcDecl.returnType);
    const parameters = funcDecl.parameters.map(param => ({
      name: param.name,
      type: this.convertTypeInfo(param.type),
      defaultValue: param.defaultValue?.toString(),
      isOptional: param.optional
    }));

    const signature: FunctionSignature = {
      returnType: this.convertTypeInfo(returnType),
      parameters,
      isVirtual: funcDecl.isVirtual || false,
      isOverride: funcDecl.isOverride || false,
      isFinal: funcDecl.isFinal || false,
      isAsync: funcDecl.isAsync || false,
      templateParameters: funcDecl.templateParameters
    };

    const symbol = this.symbolTable.createFunctionSymbol(
      funcDecl.name,
      signature,
      this.getNodeLocation(funcDecl),
      funcDecl.visibility || SymbolVisibility.PUBLIC,
      !funcDecl.body
    );

    if (!this.symbolTable.addSymbol(symbol)) {
      this.reportError(
        `Function '${funcDecl.name}' is already declared`,
        funcDecl
      );
    }
  }

  /**
   * Collect class declaration
   */
  private collectClassDeclaration(classDecl: ClassDeclaration): void {
    const baseClasses = classDecl.baseClasses?.map(base => base.name) || [];
    const interfaces = classDecl.interfaces?.map(iface => iface.name) || [];

    const symbol = this.symbolTable.createClassSymbol(
      classDecl.name,
      this.getNodeLocation(classDecl),
      baseClasses,
      interfaces,
      classDecl.visibility || SymbolVisibility.PUBLIC
    );

    if (!this.symbolTable.addSymbol(symbol)) {
      this.reportError(
        `Class '${classDecl.name}' is already declared`,
        classDecl
      );
    }
  }

  /**
   * Collect interface declaration
   */
  private collectInterfaceDeclaration(interfaceDecl: InterfaceDeclaration): void {
    const typeInfo: TypeInfo = {
      name: interfaceDecl.name,
      isPointer: false,
      isReference: false,
      isArray: false,
      isConst: false,
      isVolatile: false
    };

    const symbol: Symbol = {
      name: interfaceDecl.name,
      kind: SymbolKind.INTERFACE,
      type: typeInfo,
      visibility: SymbolVisibility.PUBLIC,
      location: this.getNodeLocation(interfaceDecl),
      scope: this.symbolTable.getCurrentScope()
    };

    if (!this.symbolTable.addSymbol(symbol)) {
      this.reportError(
        `Interface '${interfaceDecl.name}' is already declared`,
        interfaceDecl
      );
    }
  }

  /**
   * Collect struct declaration
   */
  private collectStructDeclaration(structDecl: StructDeclaration): void {
    const typeInfo: TypeInfo = {
      name: structDecl.name,
      isPointer: false,
      isReference: false,
      isArray: false,
      isConst: false,
      isVolatile: false
    };

    const symbol: Symbol = {
      name: structDecl.name,
      kind: SymbolKind.STRUCT,
      type: typeInfo,
      visibility: SymbolVisibility.PUBLIC,
      location: this.getNodeLocation(structDecl),
      scope: this.symbolTable.getCurrentScope(),
      members: new Map()
    };

    if (!this.symbolTable.addSymbol(symbol)) {
      this.reportError(
        `Struct '${structDecl.name}' is already declared`,
        structDecl
      );
    }
  }

  /**
   * Collect namespace declaration
   */
  private collectNamespaceDeclaration(namespaceDecl: NamespaceDeclaration): void {
    const typeInfo: TypeInfo = {
      name: namespaceDecl.name,
      isPointer: false,
      isReference: false,
      isArray: false,
      isConst: false,
      isVolatile: false
    };

    const symbol: Symbol = {
      name: namespaceDecl.name,
      kind: SymbolKind.NAMESPACE,
      type: typeInfo,
      visibility: SymbolVisibility.PUBLIC,
      location: this.getNodeLocation(namespaceDecl),
      scope: this.symbolTable.getCurrentScope()
    };

    if (!this.symbolTable.addSymbol(symbol)) {
      this.reportError(
        `Namespace '${namespaceDecl.name}' is already declared`,
        namespaceDecl
      );
    }
  }

  /**
   * Visit declaration node
   */
  private visitDeclaration(declaration: Declaration): void {
    this.currentNode = declaration;

    switch (declaration.constructor.name) {
      case 'FunctionDeclaration':
        this.visitFunctionDeclaration(declaration as FunctionDeclaration);
        break;
      case 'ClassDeclaration':
        this.visitClassDeclaration(declaration as ClassDeclaration);
        break;
      case 'InterfaceDeclaration':
        this.visitInterfaceDeclaration(declaration as InterfaceDeclaration);
        break;
      case 'StructDeclaration':
        this.visitStructDeclaration(declaration as StructDeclaration);
        break;
      case 'VariableDeclaration':
        this.visitVariableDeclaration(declaration as VariableDeclaration);
        break;
      case 'TypeAliasDeclaration':
        this.visitTypeAliasDeclaration(declaration as TypeAliasDeclaration);
        break;
      case 'NamespaceDeclaration':
        this.visitNamespaceDeclaration(declaration as NamespaceDeclaration);
        break;
      default:
        this.reportWarning(
          `Unknown declaration type: ${declaration.constructor.name}`,
          declaration
        );
    }
  }

  /**
   * Visit function declaration
   */
  private visitFunctionDeclaration(funcDecl: FunctionDeclaration): void {
    const symbol = this.symbolTable.lookup(funcDecl.name);
    if (!symbol || symbol.kind !== SymbolKind.FUNCTION) {
      this.reportError(
        `Function '${funcDecl.name}' not found in symbol table`,
        funcDecl
      );
      return;
    }

    /* Enter function scope */
    const functionScope = this.symbolTable.enterScope(
      ScopeType.FUNCTION,
      funcDecl.name,
      this.getNodeLocation(funcDecl)
    );

    const previousFunction = this.context.currentFunction;
    this.context.currentFunction = symbol;
    this.context.returnType = this.typeChecker.convertTypeInfo(symbol.type);

    /* Add parameters to function scope */
    if (funcDecl.parameters) {
      for (const param of funcDecl.parameters) {
        const paramType = this.convertTypeNode(param.type);
        const paramSymbol: Symbol = {
          name: param.name,
          kind: SymbolKind.PARAMETER,
          type: paramType,
          visibility: SymbolVisibility.PUBLIC,
          location: this.getNodeLocation(param),
          scope: functionScope
        };

        if (!this.symbolTable.addSymbol(paramSymbol)) {
          this.reportError(
            `Parameter '${param.name}' is already declared`,
            param
          );
        }
      }
    }

    /* Analyze function body */
    if (funcDecl.body) {
      this.visitStatement(funcDecl.body);

      /* Check return paths */
      this.validateReturnPaths(funcDecl, symbol);
    }

    /* Exit function scope */
    this.symbolTable.exitScope();
    this.context.currentFunction = previousFunction;
    this.context.returnType = undefined;
  }

  /**
   * Visit class declaration
   */
  private visitClassDeclaration(classDecl: ClassDeclaration): void {
    const symbol = this.symbolTable.lookup(classDecl.name);
    if (!symbol || symbol.kind !== SymbolKind.CLASS) {
      this.reportError(
        `Class '${classDecl.name}' not found in symbol table`,
        classDecl
      );
      return;
    }

    /* Enter class scope */
    this.symbolTable.enterScope(
      ScopeType.CLASS,
      classDecl.name,
      this.getNodeLocation(classDecl)
    );

    const previousClass = this.context.currentClass;
    this.context.currentClass = symbol;

    /* Validate inheritance */
    if (classDecl.baseClasses) {
      for (const baseClass of classDecl.baseClasses) {
        this.validateInheritance(classDecl, baseClass);
      }
    }

    /* Validate interface implementation */
    if (classDecl.interfaces) {
      for (const interfaceRef of classDecl.interfaces) {
        this.validateInterfaceImplementation(classDecl, interfaceRef);
      }
    }

    /* Analyze class members */
    for (const member of classDecl.members) {
      this.visitDeclaration(member);
    }

    /* Exit class scope */
    this.symbolTable.exitScope();
    this.context.currentClass = previousClass;
  }

  /**
   * Visit interface declaration
   */
  private visitInterfaceDeclaration(interfaceDecl: InterfaceDeclaration): void {
    /* Enter interface scope */
    this.symbolTable.enterScope(
      ScopeType.INTERFACE,
      interfaceDecl.name,
      this.getNodeLocation(interfaceDecl)
    );

    /* Analyze interface members */
    for (const member of interfaceDecl.members) {
      this.visitDeclaration(member);
    }

    /* Exit interface scope */
    this.symbolTable.exitScope();
  }

  /**
   * Visit struct declaration
   */
  private visitStructDeclaration(structDecl: StructDeclaration): void {
    const symbol = this.symbolTable.lookup(structDecl.name);
    if (!symbol || symbol.kind !== SymbolKind.STRUCT) {
      this.reportError(
        `Struct '${structDecl.name}' not found in symbol table`,
        structDecl
      );
      return;
    }

    /* Enter struct scope */
    this.symbolTable.enterScope(
      ScopeType.CLASS,
      structDecl.name,
      this.getNodeLocation(structDecl)
    );

    /* Analyze struct members */
    for (const member of structDecl.members) {
      this.visitDeclaration(member);

      /* Add member to struct symbol */
      if (member.constructor.name === 'VariableDeclaration') {
        const varDecl = member as VariableDeclaration;
        const memberType = this.convertTypeNode(varDecl.type);
        symbol.members?.set(varDecl.name, {
          name: varDecl.name,
          kind: SymbolKind.FIELD,
          type: memberType,
          visibility: varDecl.visibility || SymbolVisibility.PUBLIC,
          location: this.getNodeLocation(varDecl),
          scope: this.symbolTable.getCurrentScope()
        });
      }
    }

    /* Exit struct scope */
    this.symbolTable.exitScope();
  }

  /**
   * Visit variable declaration
   */
  private visitVariableDeclaration(varDecl: VariableDeclaration): void {
    const type = this.convertTypeNode(varDecl.type);

    /* Handle auto type inference */
    if (type.name === 'auto' || type.name === 'var') {
      if (varDecl.initializer) {
        const initType = this.visitExpression(varDecl.initializer);
        if (initType) {
          type.name = initType.name;
        } else {
          this.reportError(
            `Cannot infer type for variable '${varDecl.name}'`,
            varDecl
          );
        }
      } else {
        this.reportError(
          `Variable '${varDecl.name}' with auto type must have initializer`,
          varDecl
        );
      }
    }

    const symbol: Symbol = {
      name: varDecl.name,
      kind: SymbolKind.VARIABLE,
      type,
      visibility: varDecl.visibility || SymbolVisibility.PUBLIC,
      location: this.getNodeLocation(varDecl),
      scope: this.symbolTable.getCurrentScope()
    };

    if (!this.symbolTable.addSymbol(symbol)) {
      this.reportError(
        `Variable '${varDecl.name}' is already declared`,
        varDecl
      );
      return;
    }

    /* Validate initializer */
    if (varDecl.initializer) {
      const initType = this.visitExpression(varDecl.initializer);
      if (initType) {
        const varType = this.typeChecker.convertTypeInfo(type);
        const initDescriptor = this.typeChecker.convertTypeInfo(this.convertTypeDescriptorToInfo(initType));

        if (!this.typeChecker.isAssignable(initDescriptor, varType)) {
          this.reportError(
            `Cannot initialize variable '${varDecl.name}' of type '${type.name}' with value of type '${initType.name}'`,
            varDecl
          );
        }
      }
    }
  }

  /**
   * Visit type alias declaration
   */
  private visitTypeAliasDeclaration(typeAlias: TypeAliasDeclaration): void {
    const targetType = this.convertTypeNode(typeAlias.type);
    const targetDescriptor = this.typeChecker.convertTypeInfo(targetType);

    this.typeRegistry.registerAlias(typeAlias.name, targetDescriptor);

    const symbol: Symbol = {
      name: typeAlias.name,
      kind: SymbolKind.TYPEDEF,
      type: targetType,
      visibility: SymbolVisibility.PUBLIC,
      location: this.getNodeLocation(typeAlias),
      scope: this.symbolTable.getCurrentScope()
    };

    if (!this.symbolTable.addSymbol(symbol)) {
      this.reportError(
        `Type alias '${typeAlias.name}' is already declared`,
        typeAlias
      );
    }
  }

  /**
   * Visit namespace declaration
   */
  private visitNamespaceDeclaration(namespaceDecl: NamespaceDeclaration): void {
    /* Enter namespace scope */
    this.symbolTable.enterScope(
      ScopeType.NAMESPACE,
      namespaceDecl.name,
      this.getNodeLocation(namespaceDecl)
    );

    const previousNamespace = this.context.currentNamespace;
    const symbol = this.symbolTable.lookup(namespaceDecl.name);
    this.context.currentNamespace = symbol;

    /* Analyze namespace members */
    for (const member of namespaceDecl.members) {
      this.visitDeclaration(member);
    }

    /* Exit namespace scope */
    this.symbolTable.exitScope();
    this.context.currentNamespace = previousNamespace;
  }

  /**
   * Visit statement node
   */
  private visitStatement(statement: Statement): void {
    this.currentNode = statement;

    switch (statement.constructor.name) {
      case 'BlockStatement':
        this.visitBlockStatement(statement as BlockStatement);
        break;
      case 'ExpressionStatement':
        this.visitExpressionStatement(statement as ExpressionStatement);
        break;
      case 'IfStatement':
        this.visitIfStatement(statement as IfStatement);
        break;
      case 'WhileStatement':
        this.visitWhileStatement(statement as WhileStatement);
        break;
      case 'ForStatement':
        this.visitForStatement(statement as ForStatement);
        break;
      case 'ReturnStatement':
        this.visitReturnStatement(statement as ReturnStatement);
        break;
      default:
        this.reportWarning(
          `Unknown statement type: ${statement.constructor.name}`,
          statement
        );
    }
  }

  /**
   * Visit block statement
   */
  private visitBlockStatement(blockStmt: BlockStatement): void {
    /* Enter block scope */
    this.symbolTable.enterScope(
      ScopeType.BLOCK,
      `block_${Date.now()}`,
      this.getNodeLocation(blockStmt)
    );

    for (const statement of blockStmt.statements) {
      this.visitStatement(statement);
    }

    /* Exit block scope */
    this.symbolTable.exitScope();
  }

  /**
   * Visit expression statement
   */
  private visitExpressionStatement(exprStmt: ExpressionStatement): void {
    this.visitExpression(exprStmt.expression);
  }

  /**
   * Visit if statement
   */
  private visitIfStatement(ifStmt: IfStatement): void {
    /* Check condition type */
    const conditionType = this.visitExpression(ifStmt.test);
    if (conditionType) {
      const boolType = this.typeRegistry.getType('bool');
      if (boolType && !this.typeChecker.isAssignable(conditionType, boolType)) {
        this.reportWarning(
          `Condition should be boolean type, got '${conditionType.name}'`,
          ifStmt
        );
      }
    }

    this.visitStatement(ifStmt.consequent);

    if (ifStmt.alternate) {
      this.visitStatement(ifStmt.alternate);
    }
  }

  /**
   * Visit while statement
   */
  private visitWhileStatement(whileStmt: WhileStatement): void {
    const wasInLoop = this.context.isInLoop;
    this.context.isInLoop = true;

    /* Check condition type */
    const conditionType = this.visitExpression(whileStmt.test);
    if (conditionType) {
      const boolType = this.typeRegistry.getType('bool');
      if (boolType && !this.typeChecker.isAssignable(conditionType, boolType)) {
        this.reportWarning(
          `While condition should be boolean type, got '${conditionType.name}'`,
          whileStmt
        );
      }
    }

    this.visitStatement(whileStmt.body);

    this.context.isInLoop = wasInLoop;
  }

  /**
   * Visit for statement
   */
  private visitForStatement(forStmt: ForStatement): void {
    const wasInLoop = this.context.isInLoop;
    this.context.isInLoop = true;

    /* Enter for scope */
    this.symbolTable.enterScope(
      ScopeType.BLOCK,
      `for_${Date.now()}`,
      this.getNodeLocation(forStmt)
    );

    if (forStmt.init) {
      if (forStmt.init.constructor.name === 'VariableDeclaration') {
        this.visitVariableDeclaration(forStmt.init as VariableDeclaration);
      } else {
        this.visitExpression(forStmt.init as Expression);
      }
    }

    if (forStmt.test) {
      const conditionType = this.visitExpression(forStmt.test);
      if (conditionType) {
        const boolType = this.typeRegistry.getType('bool');
        if (boolType && !this.typeChecker.isAssignable(conditionType, boolType)) {
          this.reportWarning(
            `For condition should be boolean type, got '${conditionType.name}'`,
            forStmt
          );
        }
      }
    }

    if (forStmt.update) {
      this.visitExpression(forStmt.update);
    }

    this.visitStatement(forStmt.body);

    /* Exit for scope */
    this.symbolTable.exitScope();
    this.context.isInLoop = wasInLoop;
  }

  /**
   * Visit return statement
   */
  private visitReturnStatement(returnStmt: ReturnStatement): void {
    if (!this.context.currentFunction) {
      this.reportError(
        'Return statement outside of function',
        returnStmt
      );
      return;
    }

    const expectedReturnType = this.context.returnType;
    if (!expectedReturnType) {
      this.reportError(
        'No return type context available',
        returnStmt
      );
      return;
    }

    if (returnStmt.argument) {
      const returnType = this.visitExpression(returnStmt.argument);
      if (returnType && !this.typeChecker.isAssignable(returnType, expectedReturnType)) {
        this.reportError(
          `Cannot return '${returnType.name}' from function expecting '${expectedReturnType.name}'`,
          returnStmt
        );
      }
    } else {
      /* Void return */
      if (expectedReturnType.name !== 'void') {
        this.reportError(
          `Function expects return value of type '${expectedReturnType.name}'`,
          returnStmt
        );
      }
    }
  }

  /**
   * Visit expression node
   */
  private visitExpression(expression: Expression): TypeDescriptor | undefined {
    this.currentNode = expression;

    switch (expression.constructor.name) {
      case 'BinaryExpression':
        return this.visitBinaryExpression(expression as BinaryExpression);
      case 'UnaryExpression':
        return this.visitUnaryExpression(expression as UnaryExpression);
      case 'CallExpression':
        return this.visitCallExpression(expression as CallExpression);
      case 'MemberExpression':
        return this.visitMemberExpression(expression as MemberExpression);
      case 'AssignmentExpression':
        return this.visitAssignmentExpression(expression as AssignmentExpression);
      case 'Identifier':
        return this.visitIdentifier(expression as Identifier);
      case 'Literal':
        return this.visitLiteral(expression as Literal);
      default:
        this.reportWarning(
          `Unknown expression type: ${expression.constructor.name}`,
          expression
        );
        return undefined;
    }
  }

  /**
   * Visit binary expression
   */
  private visitBinaryExpression(binExpr: BinaryExpression): TypeDescriptor | undefined {
    const leftType = this.visitExpression(binExpr.left);
    const rightType = this.visitExpression(binExpr.right);

    if (!leftType || !rightType) {
      return undefined;
    }

    /* Validate operator for types */
    if (!this.typeChecker.validateOperatorOverload(binExpr.operator, [leftType, rightType])) {
      this.reportError(
        `Operator '${binExpr.operator}' not valid for types '${leftType.name}' and '${rightType.name}'`,
        binExpr
      );
      return undefined;
    }

    /* Return result type based on operator */
    switch (binExpr.operator) {
      case '==':
      case '!=':
      case '<':
      case '>':
      case '<=':
      case '>=':
      case '&&':
      case '||':
        return this.typeRegistry.getType('bool');

      case '+':
      case '-':
      case '*':
      case '/':
      case '%':
        /* Return the "wider" type */
        return this.getWiderType(leftType, rightType);

      default:
        return leftType;
    }
  }

  /**
   * Visit unary expression
   */
  private visitUnaryExpression(unaryExpr: UnaryExpression): TypeDescriptor | undefined {
    const operandType = this.visitExpression(unaryExpr.argument);

    if (!operandType) {
      return undefined;
    }

    /* Validate operator for type */
    if (!this.typeChecker.validateOperatorOverload(unaryExpr.operator, [operandType])) {
      this.reportError(
        `Operator '${unaryExpr.operator}' not valid for type '${operandType.name}'`,
        unaryExpr
      );
      return undefined;
    }

    /* Return result type based on operator */
    switch (unaryExpr.operator) {
      case '!':
        return this.typeRegistry.getType('bool');
      case '++':
      case '--':
      case '+':
      case '-':
      case '~':
        return operandType;
      default:
        return operandType;
    }
  }

  /**
   * Visit call expression
   */
  private visitCallExpression(callExpr: CallExpression): TypeDescriptor | undefined {
    const calleeType = this.visitExpression(callExpr.callee);

    /* Get function symbol */
    let functionSymbol: Symbol | undefined;
    if (callExpr.callee.constructor.name === 'Identifier') {
      const identifier = callExpr.callee as Identifier;
      functionSymbol = this.symbolTable.lookup(identifier.name);
    }

    if (!functionSymbol || functionSymbol.kind !== SymbolKind.FUNCTION) {
      this.reportError(
        `'${callExpr.callee}' is not a function`,
        callExpr
      );
      return undefined;
    }

    /* Check argument types */
    const argumentTypes: TypeDescriptor[] = [];
    for (const arg of callExpr.arguments) {
      const argType = this.visitExpression(arg);
      if (argType) {
        argumentTypes.push(argType);
      }
    }

    /* Validate function call */
    if (functionSymbol.signature) {
      if (argumentTypes.length !== functionSymbol.signature.parameters.length) {
        this.reportError(
          `Function '${functionSymbol.name}' expects ${functionSymbol.signature.parameters.length} arguments, got ${argumentTypes.length}`,
          callExpr
        );
        return undefined;
      }

      /* Check argument types */
      for (let i = 0; i < argumentTypes.length; i++) {
        const paramType = this.typeChecker.convertTypeInfo(functionSymbol.signature.parameters[i].type);
        const argType = argumentTypes[i];

        if (!this.typeChecker.isAssignable(argType, paramType)) {
          this.reportError(
            `Argument ${i + 1} of function '${functionSymbol.name}' expected '${paramType.name}', got '${argType.name}'`,
            callExpr
          );
        }
      }

      return this.typeChecker.convertTypeInfo(functionSymbol.signature.returnType);
    }

    return undefined;
  }

  /**
   * Visit member expression
   */
  private visitMemberExpression(memberExpr: MemberExpression): TypeDescriptor | undefined {
    const objectType = this.visitExpression(memberExpr.object);

    if (!objectType) {
      return undefined;
    }

    /* Handle property access */
    if (memberExpr.property.constructor.name === 'Identifier') {
      const propertyName = (memberExpr.property as Identifier).name;

      /* Check if object type has this member */
      if (objectType.members) {
        const memberType = objectType.members.get(propertyName);
        if (memberType) {
          return memberType;
        }
      }

      /* Check for built-in members (like vector components) */
      if (objectType.name.startsWith('vec') || objectType.name.startsWith('ivec')) {
        if (['x', 'y', 'z', 'w'].includes(propertyName)) {
          const componentType = objectType.name.startsWith('vec') ? 'float' : 'int';
          return this.typeRegistry.getType(componentType);
        }
      }

      this.reportError(
        `Type '${objectType.name}' has no member '${propertyName}'`,
        memberExpr
      );
    }

    return undefined;
  }

  /**
   * Visit assignment expression
   */
  private visitAssignmentExpression(assignExpr: AssignmentExpression): TypeDescriptor | undefined {
    const leftType = this.visitExpression(assignExpr.left);
    const rightType = this.visitExpression(assignExpr.right);

    if (!leftType || !rightType) {
      return undefined;
    }

    if (!this.typeChecker.isAssignable(rightType, leftType)) {
      this.reportError(
        `Cannot assign '${rightType.name}' to '${leftType.name}'`,
        assignExpr
      );
    }

    return leftType;
  }

  /**
   * Visit identifier
   */
  private visitIdentifier(identifier: Identifier): TypeDescriptor | undefined {
    const symbol = this.symbolTable.lookup(identifier.name);

    if (!symbol) {
      this.reportError(
        `Undefined identifier '${identifier.name}'`,
        identifier
      );
      return undefined;
    }

    /* Increment usage count */
    if (typeof symbol.usageCount === 'number') {
      symbol.usageCount++;
    } else {
      symbol.usageCount = 1;
    }

    return this.typeChecker.convertTypeInfo(symbol.type);
  }

  /**
   * Visit literal
   */
  private visitLiteral(literal: Literal): TypeDescriptor | undefined {
    switch (typeof literal.value) {
      case 'number':
        return literal.value % 1 === 0
          ? this.typeRegistry.getType('int')
          : this.typeRegistry.getType('float');
      case 'string':
        return this.typeRegistry.getType('string');
      case 'boolean':
        return this.typeRegistry.getType('bool');
      default:
        return this.typeRegistry.getType('any');
    }
  }

  /**
   * Helper methods
   */

  private convertTypeNode(typeNode: any): TypeInfo {
    /* Convert AST type node to TypeInfo */
    return {
      name: typeNode?.name || 'unknown',
      isPointer: typeNode?.isPointer || false,
      isReference: typeNode?.isReference || false,
      isArray: typeNode?.isArray || false,
      isConst: typeNode?.isConst || false,
      isVolatile: typeNode?.isVolatile || false
    };
  }

  private convertTypeDescriptorToInfo(descriptor: TypeDescriptor): TypeInfo {
    return {
      name: descriptor.name,
      isPointer: descriptor.kind === TypeKind.POINTER,
      isReference: descriptor.kind === TypeKind.REFERENCE,
      isArray: descriptor.kind === TypeKind.ARRAY,
      isConst: descriptor.isConst,
      isVolatile: descriptor.isVolatile
    };
  }

  private getWiderType(type1: TypeDescriptor, type2: TypeDescriptor): TypeDescriptor {
    /* Simple type widening rules */
    const typeHierarchy = ['char', 'int', 'float', 'double'];

    const index1 = typeHierarchy.indexOf(type1.name);
    const index2 = typeHierarchy.indexOf(type2.name);

    if (index1 >= 0 && index2 >= 0) {
      return index1 > index2 ? type1 : type2;
    }

    return type1;
  }

  private getNodeLocation(node?: ASTNode): SourceLocation {
    return {
      line: (node as any)?.location?.line || 0,
      column: (node as any)?.location?.column || 0,
      file: (node as any)?.location?.filename || '<unknown>'
    };
  }

  private reportError(message: string, node?: ASTNode): void {
    globalErrorHandler.reportSemanticError(
      message,
      this.getNodeLocation(node),
      'Check variable declarations, type compatibility, and symbol resolution'
    );
  }

  private reportWarning(message: string, node?: ASTNode): void {
    globalErrorHandler.reportWarning(
      message,
      this.getNodeLocation(node),
      'Consider reviewing this code for potential issues'
    );
  }

  private validateForwardDeclarations(): void {
    /* Check that all forward declarations have corresponding definitions */
    const allSymbols = this.symbolTable.getGlobalScope().getAllSymbols();

    for (const [name, symbol] of allSymbols) {
      if (symbol.isForwardDeclaration && !symbol.isDefinition) {
        this.reportError(
          `Forward declaration of '${name}' has no corresponding definition`,
          undefined
        );
      }
    }
  }

  private validateReturnPaths(funcDecl: FunctionDeclaration, symbol: Symbol): void {
    if (!symbol.signature || symbol.signature.returnType.name === 'void') {
      return; /* Void functions don't need return values */
    }

    /* This is a simplified check - a full implementation would analyze all code paths */
    const hasReturn = this.hasReturnStatement(funcDecl.body);
    if (!hasReturn) {
      this.reportWarning(
        `Function '${funcDecl.name}' may not return a value on all paths`,
        funcDecl
      );
    }
  }

  private hasReturnStatement(statement: Statement): boolean {
    if (statement.constructor.name === 'ReturnStatement') {
      return true;
    }

    if (statement.constructor.name === 'BlockStatement') {
      const blockStmt = statement as BlockStatement;
      for (const stmt of blockStmt.statements) {
        if (this.hasReturnStatement(stmt)) {
          return true;
        }
      }
    }

    return false;
  }

  private validateInheritance(classDecl: ClassDeclaration, baseClass: any): void {
    const baseSymbol = this.symbolTable.lookup(baseClass.name);
    if (!baseSymbol || baseSymbol.kind !== SymbolKind.CLASS) {
      this.reportError(
        `Base class '${baseClass.name}' not found`,
        classDecl
      );
    }
  }

  private validateInterfaceImplementation(classDecl: ClassDeclaration, interfaceRef: any): void {
    const interfaceSymbol = this.symbolTable.lookup(interfaceRef.name);
    if (!interfaceSymbol || interfaceSymbol.kind !== SymbolKind.INTERFACE) {
      this.reportError(
        `Interface '${interfaceRef.name}' not found`,
        classDecl
      );
    }
  }
}

/**
 * Global semantic analyzer instance
 */
export const globalSemanticAnalyzer = new SemanticAnalyzer();
